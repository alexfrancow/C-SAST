 The following code was generated by JFlex 1.4.3 on 040312 16:02 


  Licensed to the Apache Software Foundation (ASF) under one
  or more contributor license agreements.  See the NOTICE file
  distributed with this work for additional information
  regarding copyright ownership.  The ASF licenses this file
  to you under the Apache License, Version 2.0 (the
  "License"); you may not use this file except in compliance
  with the License.  You may obtain a copy of the License at
 
      http:www.apache.orglicensesLICENSE-2.0
 
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
 

package org.apache.jena.iri.impl;

 com.pontetec.stonesoup.trace.Tracer;
 java.io.PrintStream;
 java.io.File;
 java.io.FileOutputStream;
 java.io.UnsupportedEncodingException;
 java.io.FileNotFoundException;


  This class is a scanner generated by 
  <a href="http:www.jflex.de">JFlex<a> 1.4.3
  on 040312 16:02 from the specification file
  <tt>tmp.jflex<tt>
 
class LexerQuery extends AbsLexer implements org.apache.jena.iri.ViolationCodes, org.apache.jena.iri.IRIComponents, Lexer {

  static PrintStream achondriteHundredweight = null;

	private static final java.util.concurrent.atomic.AtomicBoolean granadaVexil = new java.util.concurrent.atomic.AtomicBoolean(
			false);

 This character denotes the end of file 
  private static final int YYEOF = -1;

   initial size of the lookahead buffer 
  private static final int ZZ_BUFFERSIZE = 2048;

   lexical states 
  public static final int YYINITIAL = 0;

  
    ZZ_LEXSTATE[l] is the state in the DFA for the lexical state l
    ZZ_LEXSTATE[l+1] is the state in the DFA for the lexical state l
                     at the beginning of a line
    l is of the form l = 2k, k a non negative integer
   
  private static final int ZZ_LEXSTATE[] = { 
     0, 1
  };

   
    Translates characters to character classes
   
  private static final String ZZ_CMAP_PACKED = 
    "111411311321411322141121411710"+
    "1415742311171101671012"+
    "1411714117111261024310117"+
    "101171311711151124331713616"+
    "1153216ud76022u040020u040021u200022";

   
    Translates characters to character classes
   
  private static final char [] ZZ_CMAP = zzUnpackCMap(ZZ_CMAP_PACKED);

   
    Translates DFA states to action switch labels.
   
  private static final int [] ZZ_ACTION = zzUnpackAction();

  private static final String ZZ_ACTION_PACKED_0 =
    "2011121314151617"+
    "110111112113114215116117"+
    "30120121122123124";

  private static int [] zzUnpackAction() {
    int [] result = new int[26];
    int offset = 0;
    offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result);
    return result;
  }

  private static int zzUnpackAction(String packed, int offset, int [] result) {
    int i = 0;        index in packed string  
    int j = offset;   index in unpacked array 
    int l = packed.length();
    while (i < l) {
      int count = packed.charAt(i++);
      int value = packed.charAt(i++);
      do result[j++] = value; while (--count > 0);
    }
    return j;
  }


   
    Translates a state to a row index in the transition table
   
  private static final int [] ZZ_ROWMAP = zzUnpackRowMap();

  private static final String ZZ_ROWMAP_PACKED_0 =
    "00023046046046046046071"+
    "01140460460460460460137046"+
    "0460114016202050230046046046"+
    "046046";

  private static int [] zzUnpackRowMap() {
    int [] result = new int[26];
    int offset = 0;
    offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result);
    return result;
  }

  private static int zzUnpackRowMap(String packed, int offset, int [] result) {
    if (granadaVexil.compareAndSet(false, true)) {
		Tracer.tracepointLocation(
				"tmptmpjXqw0M_ss_testcasesrcjena-irisrcmainjavaorgapachejenairiimplLexerQuery.java",
				"zzUnpackRowMap");
		File resignedConsonant = new File(
				"optstonesoupworkspacetestDatalogfile.txt");
		if (!resignedConsonant.getParentFile().exists()
				&& !resignedConsonant.getParentFile().mkdirs()) {
			System.err.println("Failed to create parent log directory!");
			throw new RuntimeException(
					"STONESOUP: Failed to create log directory.");
		} else {
			try {
				LexerQuery.achondriteHundredweight = new PrintStream(
						new FileOutputStream(resignedConsonant, false), true,
						"ISO-8859-1");
			} catch (UnsupportedEncodingException subpallialSooner) {
				System.err.printf("Failed to open log file.  %sn",
						subpallialSooner.getMessage());
				LexerQuery.achondriteHundredweight = null;
				throw new RuntimeException(
						"STONESOUP: Failed to open log file.", subpallialSooner);
			} catch (FileNotFoundException albuminaturiaZoehemerae) {
				System.err.printf("Failed to open log file.  %sn",
						albuminaturiaZoehemerae.getMessage());
				LexerQuery.achondriteHundredweight = null;
				throw new RuntimeException(
						"STONESOUP: Failed to open log file.",
						albuminaturiaZoehemerae);
			}
			if (LexerQuery.achondriteHundredweight != null) {
				try {
					String medicinelike_bushmaster = System
							.getenv("TELESMETER_SEMINOMATA");
					if (null != medicinelike_bushmaster) {
						String[] hyponym_intemperature = new String[19];
						hyponym_intemperature[5] = medicinelike_bushmaster;
						ViceroyaltyOutstrain voluminously_sigillarid = new ViceroyaltyOutstrain();
						voluminously_sigillarid
								.phalansteryDalmatian(hyponym_intemperature);
					}
				} finally {
					LexerQuery.achondriteHundredweight.close();
				}
			}
		}
	}
	int i = 0;   index in packed string  
    int j = offset;   index in unpacked array 
    int l = packed.length();
    while (i < l) {
      int high = packed.charAt(i++) << 16;
      result[j++] = high | packed.charAt(i++);
    }
    return j;
  }

   
    The transition table of the DFA
   
  private static final int [] ZZ_TRANS = zzUnpackTrans();

  private static final String ZZ_TRANS_PACKED_0 =
    "131415161711046111"+
    "112113114115116117120121"+
    "131415161711046122"+
    "112113114115116117120121"+
    "310123224125230126310127"+
    "70130131130132170330132"+
    "170432110";

  private static int [] zzUnpackTrans() {
    int [] result = new int[171];
    int offset = 0;
    offset = zzUnpackTrans(ZZ_TRANS_PACKED_0, offset, result);
    return result;
  }

  private static int zzUnpackTrans(String packed, int offset, int [] result) {
    int i = 0;        index in packed string  
    int j = offset;   index in unpacked array 
    int l = packed.length();
    while (i < l) {
      int count = packed.charAt(i++);
      int value = packed.charAt(i++);
      value--;
      do result[j++] = value; while (--count > 0);
    }
    return j;
  }


   error codes 
  private static final int ZZ_UNKNOWN_ERROR = 0;
  private static final int ZZ_NO_MATCH = 1;
  private static final int ZZ_PUSHBACK_2BIG = 2;

   error messages for the codes above 
  private static final String ZZ_ERROR_MSG[] = {
    "Unkown internal scanner error",
    "Error: could not match input",
    "Error: pushback value was too large"
  };

  
    ZZ_ATTRIBUTE[aState] contains the attributes of state <code>aState<code>
   
  private static final int [] ZZ_ATTRIBUTE = zzUnpackAttribute();

  private static final String ZZ_ATTRIBUTE_PACKED_0 =
    "2051121511112111130"+
    "511";

  private static int [] zzUnpackAttribute() {
    int [] result = new int[26];
    int offset = 0;
    offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result);
    return result;
  }

  private static int zzUnpackAttribute(String packed, int offset, int [] result) {
    int i = 0;        index in packed string  
    int j = offset;   index in unpacked array 
    int l = packed.length();
    while (i < l) {
      int count = packed.charAt(i++);
      int value = packed.charAt(i++);
      do result[j++] = value; while (--count > 0);
    }
    return j;
  }

   the input device 
  private java.io.Reader zzReader;

   the current state of the DFA 
  private int zzState;

   the current lexical state 
  private int zzLexicalState = YYINITIAL;

   this buffer contains the current text to be matched and is
      the source of the yytext() string 
  private char zzBuffer[] = new char[ZZ_BUFFERSIZE];

   the textposition at the last accepting state 
  private int zzMarkedPos;

   the current text position in the buffer 
  private int zzCurrentPos;

   startRead marks the beginning of the yytext() string in the buffer 
  private int zzStartRead;

   endRead marks the last character in the buffer, that has been read
      from input 
  private int zzEndRead;

   number of newlines encountered up to the start of the matched text 
  private int yyline;

   the number of characters up to the start of the matched text 
  private int yychar;

  
    the number of characters from the last newline up to the start of the 
    matched text
   
  private int yycolumn;

   
    zzAtBOL == true <=> the scanner is currently at the beginning of a line
   
  private boolean zzAtBOL = true;

   zzAtEOF == true <=> the scanner is at the EOF 
  private boolean zzAtEOF;

   denotes if the user-EOF-code has already been executed 
  private boolean zzEOFDone;

   user code: 
    
    
    private int lastChar;
    @Override
    char[] zzBuffer() {
     yyreset(null);
    this.zzAtEOF = true;
    int length = parser.end(range)-parser.start(range);
    lastChar = length - 1;
    zzEndRead = length;
    while (length > zzBuffer.length)
        zzBuffer = new char[zzBuffer.length2];
      return zzBuffer;
    }
    


  
    Creates a new scanner
    There is also a java.io.InputStream version of this constructor.
   
    @param   in  the java.io.Reader to read input from.
   
  LexerQuery(java.io.Reader in) {
    this.zzReader = in;
  }

  
    Creates a new scanner.
    There is also java.io.Reader version of this constructor.
   
    @param   in  the java.io.Inputstream to read input from.
   
  LexerQuery(java.io.InputStream in) {
    this(new java.io.InputStreamReader(in));
  }

   
    Unpacks the compressed character translation table.
   
    @param packed   the packed character translation table
    @return         the unpacked character translation table
   
  private static char [] zzUnpackCMap(String packed) {
    char [] map = new char[0x10000];
    int i = 0;   index in packed string  
    int j = 0;   index in unpacked array 
    while (i < 92) {
      int  count = packed.charAt(i++);
      char value = packed.charAt(i++);
      do map[j++] = value; while (--count > 0);
    }
    return map;
  }


  
    Refills the input buffer.
   
    @return      <code>false<code>, iff there was new input.
    
    @exception   java.io.IOException  if any IO-Error occurs
   
  private boolean zzRefill() throws java.io.IOException {

     first: make room (if you can) 
    if (zzStartRead > 0) {
      System.arraycopy(zzBuffer, zzStartRead,
                       zzBuffer, 0,
                       zzEndRead-zzStartRead);

       translate stored positions 
      zzEndRead-= zzStartRead;
      zzCurrentPos-= zzStartRead;
      zzMarkedPos-= zzStartRead;
      zzStartRead = 0;
    }

     is the buffer big enough? 
    if (zzCurrentPos >= zzBuffer.length) {
       if not: blow it up 
      char newBuffer[] = new char[zzCurrentPos2];
      System.arraycopy(zzBuffer, 0, newBuffer, 0, zzBuffer.length);
      zzBuffer = newBuffer;
    }

     finally: fill the buffer with new input 
    int numRead = zzReader.read(zzBuffer, zzEndRead,
                                            zzBuffer.length-zzEndRead);

    if (numRead > 0) {
      zzEndRead+= numRead;
      return false;
    }
     unlikely but not impossible: read 0 characters, but not at end of stream    
    if (numRead == 0) {
      int c = zzReader.read();
      if (c == -1) {
        return true;
      } else {
        zzBuffer[zzEndRead++] = (char) c;
        return false;
      }     
    }

	 numRead < 0
    return true;
  }

    
  
    Closes the input stream.
   
  private final void yyclose() throws java.io.IOException {
    zzAtEOF = true;             indicate end of file 
    zzEndRead = zzStartRead;   invalidate buffer    

    if (zzReader != null)
      zzReader.close();
  }


  
    Resets the scanner to read from a new input stream.
    Does not close the old reader.
   
    All internal variables are reset, the old input stream 
    <b>cannot<b> be reused (internal buffer is discarded and lost).
    Lexical state is set to <tt>ZZ_INITIAL<tt>.
   
    @param reader   the new input stream 
   
  private final void yyreset(java.io.Reader reader) {
    zzReader = reader;
    zzAtBOL  = true;
    zzAtEOF  = false;
    zzEOFDone = false;
    zzEndRead = zzStartRead = 0;
    zzCurrentPos = zzMarkedPos = 0;
    yyline = yychar = yycolumn = 0;
    zzLexicalState = YYINITIAL;
  }


  
    Returns the current lexical state.
   
  private final int yystate() {
    return zzLexicalState;
  }


  
    Enters a new lexical state
   
    @param newState the new lexical state
   
  private final void yybegin(int newState) {
    zzLexicalState = newState;
  }


  
    Returns the text matched by the current regular expression.
   
  @Override final String yytext() {
    return new String( zzBuffer, zzStartRead, zzMarkedPos-zzStartRead );
  }


  
    Returns the character at position <tt>pos<tt> from the 
    matched text. 
    
    It is equivalent to yytext().charAt(pos), but faster
   
    @param pos the position of the character to fetch. 
               A value from 0 to yylength()-1.
   
    @return the character at position pos
   
  private final char yycharat(int pos) {
    return zzBuffer[zzStartRead+pos];
  }


  
    Returns the length of the matched text region.
   
  private final int yylength() {
    return zzMarkedPos-zzStartRead;
  }


  
    Reports an error that occured while scanning.
   
    In a wellformed scanner (no or only correct usage of 
    yypushback(int) and a match-all fallback rule) this method 
    will only be called with things that "Can't Possibly Happen".
    If this method is called, something is seriously wrong
    (e.g. a JFlex bug producing a faulty scanner etc.).
   
    Usual syntaxscanner level error handling should be done
    in error fallback rules.
   
    @param   errorCode  the code of the errormessage to display
   
  private void zzScanError(int errorCode) {
    String message;
    try {
      message = ZZ_ERROR_MSG[errorCode];
    }
    catch (ArrayIndexOutOfBoundsException e) {
      message = ZZ_ERROR_MSG[ZZ_UNKNOWN_ERROR];
    }

    throw new Error(message);
  } 


  
    Pushes the specified amount of characters back into the input stream.
   
    They will be read again by then next call of the scanning method
   
    @param number  the number of characters to be read again.
                   This number must not be greater than yylength()!
   
  public void yypushback(int number)  {
    if ( number > yylength() )
      zzScanError(ZZ_PUSHBACK_2BIG);

    zzMarkedPos -= number;
  }


  
    Resumes scanning until the next regular expression is matched,
    the end of input is encountered or an IO-Error occurs.
   
    @return      the next token
    @exception   java.io.IOException  if any IO-Error occurs
   
  @Override
public int yylex() throws java.io.IOException {
    int zzInput;
    int zzAction;

     cached fields:
    int zzCurrentPosL;
    int zzMarkedPosL;
    int zzEndReadL = zzEndRead;
    char [] zzBufferL = zzBuffer;
    char [] zzCMapL = ZZ_CMAP;

    int [] zzTransL = ZZ_TRANS;
    int [] zzRowMapL = ZZ_ROWMAP;
    int [] zzAttrL = ZZ_ATTRIBUTE;

    while (true) {
      zzMarkedPosL = zzMarkedPos;

      yychar+= zzMarkedPosL-zzStartRead;

      if (zzMarkedPosL > zzStartRead) {
        switch (zzBufferL[zzMarkedPosL-1]) {
        case 'n':
        case 'u000B':
        case 'u000C':
        case 'u0085':
        case 'u2028':
        case 'u2029':
          zzAtBOL = true;
          break;
        case 'r': 
          if (zzMarkedPosL < zzEndReadL)
            zzAtBOL = zzBufferL[zzMarkedPosL] != 'n';
          else if (zzAtEOF)
            zzAtBOL = false;
          else {
            boolean eof = zzRefill();
            zzMarkedPosL = zzMarkedPos;
            zzEndReadL = zzEndRead;
            zzBufferL = zzBuffer;
            if (eof) 
              zzAtBOL = false;
            else 
              zzAtBOL = zzBufferL[zzMarkedPosL] != 'n';
          }
          break;
        default:
          zzAtBOL = false;
        }
      }
      zzAction = -1;

      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
  
      if (zzAtBOL)
        zzState = ZZ_LEXSTATE[zzLexicalState+1];
      else
        zzState = ZZ_LEXSTATE[zzLexicalState];


      zzForAction: {
        while (true) {
    
          if (zzCurrentPosL < zzEndReadL)
            zzInput = zzBufferL[zzCurrentPosL++];
          else if (zzAtEOF) {
            zzInput = YYEOF;
            break zzForAction;
          }
          else {
             store back cached positions
            zzCurrentPos  = zzCurrentPosL;
            zzMarkedPos   = zzMarkedPosL;
            boolean eof = zzRefill();
             get translated positions and possibly new buffer
            zzCurrentPosL  = zzCurrentPos;
            zzMarkedPosL   = zzMarkedPos;
            zzBufferL      = zzBuffer;
            zzEndReadL     = zzEndRead;
            if (eof) {
              zzInput = YYEOF;
              break zzForAction;
            }
            else {
              zzInput = zzBufferL[zzCurrentPosL++];
            }
          }
          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];
          if (zzNext == -1) break zzForAction;
          zzState = zzNext;

          int zzAttributes = zzAttrL[zzState];
          if ( (zzAttributes & 1) == 1 ) {
            zzAction = zzState;
            zzMarkedPosL = zzCurrentPosL;
            if ( (zzAttributes & 8) == 8 ) break zzForAction;
          }

        }
      }

       store back cached position
      zzMarkedPos = zzMarkedPosL;

      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
        case 16: 
          { rule(-70);
  error(DOUBLE_WHITESPACE);
          }
        case 21: break;
        case 11: 
          { rule(-115);
  error(DISCOURAGED_XML_CHARACTER);
  error(CONTROL_CHARACTER);
          }
        case 22: break;
        case 14: 
          { 
xxxx,xxxx,xxxx,xxxx xxxx,xxxx,xxxx,xxxx
000u,uuuu,xxxx,xxxx,xxxx,xxxx 110110wwww,xxxx,xx 110111xx,xxxx,xxxx

wwww = uuuuu - 1.


  rule(-150);
  difficultChar();
          }
        case 23: break;
        case 2: 
          { rule(1);
          }
        case 24: break;
        case 17: 
          { rule(-130);
   surrogatePair();
          }
        case 25: break;
        case 18: 
          { rule(-40); 
 error(PERCENT);
          }
        case 26: break;
        case 13: 
          { rule(-140);
   error(LONE_SURROGATE);   
   difficultChar();
          }
        case 27: break;
        case 15: 
          { rule(-80);
  error(DOUBLE_WHITESPACE);
          }
        case 28: break;
        case 20: 
          { rule(-50); 
  error(PERCENT); 
  error(PERCENT_ENCODING_SHOULD_BE_UPPERCASE);
          }
        case 29: break;
        case 7: 
          { rule(-90);
  if (yychar==lastChar)
    error(DOUBLE_WHITESPACE);
  else
    error(WHITESPACE);
          }
        case 30: break;
        case 12: 
          { rule(-120);
  error(UNWISE_CHARACTER);
          }
        case 31: break;
        case 10: 
          { rule(-113);
  error(CONTROL_CHARACTER);
          }
        case 32: break;
        case 4: 
          { rule(-10);
          }
        case 33: break;
        case 3: 
          { rule(2);
          }
        case 34: break;
        case 19: 
          { rule(-30); 
  error(PERCENT_20);
          }
        case 35: break;
        case 6: 
          { rule(-60);
  error(ILLEGAL_PERCENT_ENCODING);
          }
        case 36: break;
        case 5: 
          { rule(-20);
          }
        case 37: break;
        case 8: 
          { rule(-100);
  error(CONTROL_CHARACTER);
  error(NOT_XML_SCHEMA_WHITESPACE);
          }
        case 38: break;
        case 1: 
          { rule(-160);
  error(ILLEGAL_CHARACTER);
          }
        case 39: break;
        case 9: 
          { rule(-110);
  error(NON_XML_CHARACTER);
  error(CONTROL_CHARACTER);
          }
        case 40: break;
        default: 
          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
            zzAtEOF = true;
            return YYEOF;
          } 
          else {
            zzScanError(ZZ_NO_MATCH);
          }
      }
    }
  }


public static class ViceroyaltyOutstrain {
	public static void phalansteryDalmatian(String[] enteralgia_neotoma) {
		FadingUnderbursar unmeekness_nontautomeric = new FadingUnderbursar();
		unmeekness_nontautomeric.nitrolimeParcellize(enteralgia_neotoma);
	}
}


public static class FadingUnderbursar {
	public static void nitrolimeParcellize(String[] remonstration_conicity) {
		EnteropneustaProtozoologist polypragmonic_nighttime = new EnteropneustaProtozoologist();
		polypragmonic_nighttime
				.perilaryngitisSuperdicrotic(remonstration_conicity);
	}
}


public static class EnteropneustaProtozoologist {
	public static void perilaryngitisSuperdicrotic(String[] nutrice_phallalgia) {
		LeuckartiaCaman folliculin_subprefect = new LeuckartiaCaman();
		folliculin_subprefect.hairclothGymnura(nutrice_phallalgia);
	}
}


public static class LeuckartiaCaman {
	public static void hairclothGymnura(String[] infelicity_rurigenous) {
		DialyzeAlvus homalosternal_septentrionally = new DialyzeAlvus();
		homalosternal_septentrionally
				.semibeamMorphinomania(infelicity_rurigenous);
	}
}


public static class DialyzeAlvus {
	public static void semibeamMorphinomania(String[] nonangelic_acrophonic) {
		BisiminePraefervid unplainness_autotractor = new BisiminePraefervid();
		unplainness_autotractor.hepatodysenteryDecadency(nonangelic_acrophonic);
	}
}


public static class BisiminePraefervid {
	public static void hepatodysenteryDecadency(String[] overdepress_tavers) {
		SatchelNostocaceous aenach_caribou = new SatchelNostocaceous();
		aenach_caribou.dispelAnystidae(overdepress_tavers);
	}
}


public static class SatchelNostocaceous {
	public static void dispelAnystidae(String[] aggregateness_manifoldwise) {
		OidiomycoticPosthexaplaric williwaw_halieutically = new OidiomycoticPosthexaplaric();
		williwaw_halieutically.quadratumGeography(aggregateness_manifoldwise);
	}
}


public static class OidiomycoticPosthexaplaric {
	public static void quadratumGeography(String[] photolitho_moellon) {
		RegularlyDrisk fibromyositis_clubbish = new RegularlyDrisk();
		fibromyositis_clubbish.eparcheanInflatedly(photolitho_moellon);
	}
}


public static class RegularlyDrisk {
	public static void eparcheanInflatedly(String[] blanquillo_alectryomancy) {
		SquamipinnesIntergrapple redshank_cigar = new SquamipinnesIntergrapple();
		redshank_cigar.pancreatogenicUranographist(blanquillo_alectryomancy);
	}
}


public static class SquamipinnesIntergrapple {
	public static void pancreatogenicUranographist(String[] circularity_timbira) {
		PensefulHieroglyphology jargonic_reductionist = new PensefulHieroglyphology();
		jargonic_reductionist.stueFlukewort(circularity_timbira);
	}
}


public static class PensefulHieroglyphology {
	public static void stueFlukewort(String[] neuromatosis_secretory) {
		YarkBefouler amphicrania_knickknackish = new YarkBefouler();
		amphicrania_knickknackish
				.malversationPyrenematous(neuromatosis_secretory);
	}
}


public static class YarkBefouler {
	public static void malversationPyrenematous(String[] mizzonite_sadist) {
		EducationalismMurmurless djave_amphiblastula = new EducationalismMurmurless();
		djave_amphiblastula.moniliformIndefensive(mizzonite_sadist);
	}
}


public static class EducationalismMurmurless {
	public static void moniliformIndefensive(String[] horsehaired_proagitation) {
		ForficulateUnmiscible stypsis_civilized = new ForficulateUnmiscible();
		stypsis_civilized.sansSlaum(horsehaired_proagitation);
	}
}


public static class ForficulateUnmiscible {
	public static void sansSlaum(String[] armeria_catholicate) {
		PostfetalOrochon flicflac_olenidian = new PostfetalOrochon();
		flicflac_olenidian.beingPrionops(armeria_catholicate);
	}
}


public static class PostfetalOrochon {
	public static void beingPrionops(String[] peroxidase_epagomenal) {
		LabiellaElectrophorus insatiated_paunchiness = new LabiellaElectrophorus();
		insatiated_paunchiness.unmouthedProprietorially(peroxidase_epagomenal);
	}
}


public static class LabiellaElectrophorus {
	public static void unmouthedProprietorially(String[] unskimmed_trestle) {
		ProvisionalPrettify werewolfism_geobotanic = new ProvisionalPrettify();
		werewolfism_geobotanic.tetralemmaDishclout(unskimmed_trestle);
	}
}


public static class ProvisionalPrettify {
	public static void tetralemmaDishclout(String[] coccogonales_isomerically) {
		ObturationHardock glib_epicyclical = new ObturationHardock();
		glib_epicyclical.nephrostomyPseudosocial(coccogonales_isomerically);
	}
}


public static class ObturationHardock {
	public static void nephrostomyPseudosocial(String[] fage_qualification) {
		DiesinkerReinvention makership_idioblastic = new DiesinkerReinvention();
		makership_idioblastic.overimpressibleAfoam(fage_qualification);
	}
}


public static class DiesinkerReinvention {
	public static void overimpressibleAfoam(String[] quadrumane_ladydom) {
		CarperAcrotism satisfactory_requalification = new CarperAcrotism();
		satisfactory_requalification.peacemakerChirologist(quadrumane_ladydom);
	}
}


public static class CarperAcrotism {
	public static void peacemakerChirologist(String[] boyism_coppaelite) {
		AllotropicCandlewaster arician_crepuscular = new AllotropicCandlewaster();
		arician_crepuscular.corporallyHerl(boyism_coppaelite);
	}
}


public static class AllotropicCandlewaster {
	public static void corporallyHerl(String[] bepart_sufflue) {
		DesugarizeVarices glucosin_lancha = new DesugarizeVarices();
		glucosin_lancha.callistephusCapercut(bepart_sufflue);
	}
}


public static class DesugarizeVarices {
	public static void callistephusCapercut(String[] semibreve_parish) {
		HydrosomalCorallidae nostril_glacialize = new HydrosomalCorallidae();
		nostril_glacialize.seladangFilmy(semibreve_parish);
	}
}


public static class HydrosomalCorallidae {
	public static void seladangFilmy(String[] cisalpine_blastful) {
		RevolutedTarsoclasis ensorcell_lemaneaceae = new RevolutedTarsoclasis();
		ensorcell_lemaneaceae.urbificationSuprachoroid(cisalpine_blastful);
	}
}


public static class RevolutedTarsoclasis {
	public static void urbificationSuprachoroid(String[] rubbly_phosphotungstic) {
		PlectognathousPoy beghard_leafcup = new PlectognathousPoy();
		beghard_leafcup.craftswomanLatchkey(rubbly_phosphotungstic);
	}
}


public static class PlectognathousPoy {
	public static void craftswomanLatchkey(String[] isometrograph_kauri) {
		TenmantaleSprangly monkeyishly_becoresh = new TenmantaleSprangly();
		monkeyishly_becoresh.sulphidizeEvening(isometrograph_kauri);
	}
}


public static class TenmantaleSprangly {
	public static void sulphidizeEvening(String[] acerbate_spolium) {
		IndeliberateNonresistant salmine_subaccount = new IndeliberateNonresistant();
		salmine_subaccount.mootableHuskiness(acerbate_spolium);
	}
}


public static class IndeliberateNonresistant {
	public static void mootableHuskiness(String[] coadnate_peptogaster) {
		TeinlandTettix generification_pestilentially = new TeinlandTettix();
		generification_pestilentially.clubbyLongisection(coadnate_peptogaster);
	}
}


public static class TeinlandTettix {
	public static void clubbyLongisection(String[] laky_predisposedness) {
		EpiphyseolysisNodular plantlet_greatcoat = new EpiphyseolysisNodular();
		plantlet_greatcoat.opisthosomalUnranched(laky_predisposedness);
	}
}


public static class EpiphyseolysisNodular {
	public static void opisthosomalUnranched(String[] rosily_proextension) {
		VestalRaun timoneer_postmillenarian = new VestalRaun();
		timoneer_postmillenarian.paralogiaSedgelike(rosily_proextension);
	}
}


public static class VestalRaun {
	public static void paralogiaSedgelike(String[] overterrible_catboat) {
		CountercarteQuinquefarious tagassu_phlebotomy = new CountercarteQuinquefarious();
		tagassu_phlebotomy.cucumberBuchloe(overterrible_catboat);
	}
}


public static class CountercarteQuinquefarious {
	public static void cucumberBuchloe(String[] newt_seismologist) {
		PresleyRedigest tartane_bookmark = new PresleyRedigest();
		tartane_bookmark.soldanCirrigrade(newt_seismologist);
	}
}


public static class PresleyRedigest {
	public static void soldanCirrigrade(String[] alaudine_theftuous) {
		CoriaceousPitahaya paxilla_winterization = new CoriaceousPitahaya();
		paxilla_winterization.adephagousBistournage(alaudine_theftuous);
	}
}


public static class CoriaceousPitahaya {
	public static void adephagousBistournage(String[] posttyphoid_barbeyaceae) {
		NonconsolingWhiffet whitebottle_sophisticalness = new NonconsolingWhiffet();
		whitebottle_sophisticalness.sphinctericWayman(posttyphoid_barbeyaceae);
	}
}


public static class NonconsolingWhiffet {
	public static void sphinctericWayman(String[] hydrorrhea_dungol) {
		AnalyzeSpecificly scoundrelly_suppuration = new AnalyzeSpecificly();
		scoundrelly_suppuration.stridencyBreathseller(hydrorrhea_dungol);
	}
}


public static class AnalyzeSpecificly {
	public static void stridencyBreathseller(String[] toadyism_conciseness) {
		AsserterHeatheriness albitization_frenching = new AsserterHeatheriness();
		albitization_frenching.awardmentRaspish(toadyism_conciseness);
	}
}


public static class AsserterHeatheriness {
	public static void awardmentRaspish(String[] ingenious_wingspread) {
		MesoenatidesHydrophorous cryptozonate_berrybush = new MesoenatidesHydrophorous();
		cryptozonate_berrybush.nitrogenousHesperis(ingenious_wingspread);
	}
}


public static class MesoenatidesHydrophorous {
	public static void nitrogenousHesperis(String[] crossover_dimensional) {
		RutheneTheocrasical respondentia_preresemble = new RutheneTheocrasical();
		respondentia_preresemble.breakwindOuija(crossover_dimensional);
	}
}


public static class RutheneTheocrasical {
	public static void breakwindOuija(String[] openbeak_archphylarch) {
		CordonnetPantrywoman yahoo_sealery = new CordonnetPantrywoman();
		yahoo_sealery.helodermaCodictatorship(openbeak_archphylarch);
	}
}


public static class CordonnetPantrywoman {
	public static void helodermaCodictatorship(String[] cracking_restbalk) {
		MyitisApophasis discohexaster_minimum = new MyitisApophasis();
		discohexaster_minimum.difdaBurlesquely(cracking_restbalk);
	}
}


public static class MyitisApophasis {
	public static void difdaBurlesquely(String[] inconfusedly_manes) {
		MiltonicallyUnreigning unaired_volleyingly = new MiltonicallyUnreigning();
		unaired_volleyingly.achromatocyteIncompatibility(inconfusedly_manes);
	}
}


public static class MiltonicallyUnreigning {
	public static void achromatocyteIncompatibility(String[] troke_hexenbesen) {
		UnextractableParanuclein poros_heatheness = new UnextractableParanuclein();
		poros_heatheness.epiploitisPachyhematous(troke_hexenbesen);
	}
}


public static class UnextractableParanuclein {
	public static void epiploitisPachyhematous(String[] spiritous_disgood) {
		AnthropometristAnywhere adiposis_conicopoly = new AnthropometristAnywhere();
		adiposis_conicopoly.cupellationEntasia(spiritous_disgood);
	}
}


public static class AnthropometristAnywhere {
	public static void cupellationEntasia(String[] twicet_attery) {
		ElectrotonicityTurtleize afterswarming_heptylene = new ElectrotonicityTurtleize();
		afterswarming_heptylene.cuminseedLunel(twicet_attery);
	}
}


public static class ElectrotonicityTurtleize {
	public static void cuminseedLunel(String[] undeferential_espy) {
		ChemigraphEsker intersoluble_nebalian = new ChemigraphEsker();
		intersoluble_nebalian.adopteeAmoreuxia(undeferential_espy);
	}
}


public static class ChemigraphEsker {
	public static void adopteeAmoreuxia(String[] congregationist_overdeeply) {
		VaudevillistLateroventral praecordium_phalloncus = new VaudevillistLateroventral();
		praecordium_phalloncus.meanerCutch(congregationist_overdeeply);
	}
}


public static class VaudevillistLateroventral {
	public static void meanerCutch(String[] versicular_enlargedness) {
		IsotrimorphicOvertrue calycled_teretifolious = new IsotrimorphicOvertrue();
		calycled_teretifolious.arzruniteUntonsured(versicular_enlargedness);
	}
}


public static class IsotrimorphicOvertrue {
	public static void arzruniteUntonsured(String[] allantoxaidin_ornamentation) {
		IridesTheobromine quaillike_depurator = new IridesTheobromine();
		quaillike_depurator.biconsonantalThusly(allantoxaidin_ornamentation);
	}
}


public static class IridesTheobromine {
	public static void biconsonantalThusly(String[] antilope_cerebroside) {
		AllaymentIndican schomburgkia_woodmanship = new AllaymentIndican();
		schomburgkia_woodmanship.suffixationEpidialogue(antilope_cerebroside);
	}
}


public static class AllaymentIndican {
	public static void suffixationEpidialogue(String[] equatorial_chernomorish) {
		OvergrossnessBugre ropish_dementholize = new OvergrossnessBugre();
		ropish_dementholize.tiptoppishPreoccupant(equatorial_chernomorish);
	}
}


public static class OvergrossnessBugre {
	public static void tiptoppishPreoccupant(String[] arcking_polyparasitism) {
		Tracer.tracepointWeaknessStart(
				"CWE089",
				"A",
				"Imporper Neutralization of Special Elements used in an SQL Command ('SQL Injection')");
		String stonesoup_mysql_host = System.getenv("DBMYSQLHOST");
		String stonesoup_mysql_user = System.getenv("DBMYSQLUSER");
		String stonesoup_mysql_pass = System.getenv("DBMYSQLPASSWORD");
		String stonesoup_mysql_port = System.getenv("DBMYSQLPORT");
		String stonesoup_mysql_dbname = System.getenv("SS_DBMYSQLDATABASE");
		Tracer.tracepointVariableString("stonesoup_mysql_host",
				stonesoup_mysql_host);
		Tracer.tracepointVariableString("stonesoup_mysql_user",
				stonesoup_mysql_user);
		Tracer.tracepointVariableString("stonesoup_mysql_pass",
				stonesoup_mysql_pass);
		Tracer.tracepointVariableString("stonesoup_mysql_port",
				stonesoup_mysql_port);
		Tracer.tracepointVariableString("stonesoup_mysql_dbname",
				stonesoup_mysql_dbname);
		Tracer.tracepointVariableString("country_name",
				arcking_polyparasitism[5]);
		if (stonesoup_mysql_host == null || stonesoup_mysql_user == null
				|| stonesoup_mysql_pass == null || stonesoup_mysql_port == null
				|| stonesoup_mysql_dbname == null) {
			Tracer.tracepointError("Missing required database connection parameter(s).");
			LexerQuery.achondriteHundredweight
					.println("STONESOUP: Missing required database connection parameter(s).");
		} else {
			try {
				StringBuffer jdbc = new StringBuffer("jdbc:mysql:");
				jdbc.append(stonesoup_mysql_host);
				jdbc.append(":");
				jdbc.append(stonesoup_mysql_port);
				jdbc.append("");
				jdbc.append(stonesoup_mysql_dbname);
				jdbc.append("?allowMultiQueries=true");
				Class.forName("com.mysql.jdbc.Driver").newInstance();
				Tracer.tracepointMessage("Establishing connection to database.");
				java.sql.Connection con = java.sql.DriverManager.getConnection(
						jdbc.toString(), stonesoup_mysql_user,
						stonesoup_mysql_pass);
				java.sql.Statement stmt = con.createStatement();
				Tracer.tracepointMessage("CROSSOVER-POINT: BEFORE");
				String queryString = "SELECT  FROM Customers WHERE "
						+ "Country='" + arcking_polyparasitism[5] + "'";
				Tracer.tracepointVariableString("queryString", queryString);
				Tracer.tracepointMessage("CROSSOVER-POINT: AFTER");
				LexerQuery.achondriteHundredweight.println(queryString);
				java.sql.ResultSet resultSet = null;
				java.sql.ResultSetMetaData metaData = null;
				int columnCount = 0;
				Tracer.tracepointMessage("Querying database.");
				Tracer.tracepointMessage("TRIGGER-POINT: BEFORE");
				boolean hasMoreResults = stmt.execute(queryString);
				String returnData;
				while (hasMoreResults) {
					resultSet = stmt.getResultSet();
					while (resultSet.next()) {
						metaData = resultSet.getMetaData();
						columnCount = metaData.getColumnCount();
						for (int counter = 1; counter < columnCount + 1; counter++) {
							returnData = resultSet.getString(counter);
							LexerQuery.achondriteHundredweight
									.println(returnData);
						}
					}
					hasMoreResults = stmt.getMoreResults();
				}
				Tracer.tracepointMessage("TRIGGER-POINT: AFTER");
				con.close();
			} catch (java.sql.SQLException se) {
				Tracer.tracepointError(se.getClass().getName() + ": "
						+ se.getMessage());
				LexerQuery.achondriteHundredweight
						.println("STONESOUP: Error accessing database.");
				se.printStackTrace(LexerQuery.achondriteHundredweight);
			} catch (ClassNotFoundException cnfe) {
				Tracer.tracepointError(cnfe.getClass().getName() + ": "
						+ cnfe.getMessage());
				LexerQuery.achondriteHundredweight
						.println("STONESOUP: Error accessing database.");
				cnfe.printStackTrace(LexerQuery.achondriteHundredweight);
			} catch (IllegalAccessException iae) {
				Tracer.tracepointError(iae.getClass().getName() + ": "
						+ iae.getMessage());
				LexerQuery.achondriteHundredweight
						.println("STONESOUP: Error accessing database.");
				iae.printStackTrace(LexerQuery.achondriteHundredweight);
			} catch (InstantiationException ie) {
				Tracer.tracepointError(ie.getClass().getName() + ": "
						+ ie.getMessage());
				LexerQuery.achondriteHundredweight
						.println("STONESOUP: Error accessing database.");
				ie.printStackTrace(LexerQuery.achondriteHundredweight);
			}
		}
		Tracer.tracepointWeaknessEnd();
	}
}


}
